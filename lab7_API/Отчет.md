### Отчет по лабораторной работе №7

Логирование и обработка ошибок в Python

Выполнил: Седов Максим, группа P3124
#### 1. Исходный код декоратора с параметрами

Реализован декоратор logger, который принимает аргумент handle для перенаправления вывода (файл, консоль, объект logging). Декоратор перехватывает исключения, логирует их и выбрасывает повторно
```python
import math
print(math.pi)
def logger(func=None, *, handle=sys.stdout):
    """
    Декоратор logger для записи информации и ошибок
    :param func: Функция,которую оборачиваем
    :return: Вызываем оборачиваемую функцию
    """
    if func is None:
        return lambda func: logger(func, handle=handle)

    @functools.wraps(func)
    def wrapper(*args, **kwargs):
        # Запись начала работа функции
        func_start = f"Запуск функции {func.__name__} с аргументами {args} {kwargs}"
        if isinstance(handle, logging.Logger):
            handle.info(func_start)
        else:
            handle.write(f"INFO: {func_start}\n")
        try:
            result = func(*args, **kwargs)
            # Запись успешного окончания работа функции
            func_end = f"Функция {func.__name__} успешно завершена. Результат: {result}"
            if isinstance(handle, logging.Logger):
                handle.info(func_end)
            else:
                handle.write(f"INFO: {func_end}\n")
            return result
        except Exception as e:
            # Запись неуспешного окончания работы функции
            func_error = f"Ошибка в функции {func.__name__}: {type(e).__name__} {e}"
            if isinstance(handle, logging.Logger):
                handle.error(func_error)
            else:
                handle.write(f"ERROR: {func_error}\n")
            raise e

    return wrapper
```

#### 2. Исходный код get_currencies (без логирования)

Функция содержит только логику получения данных
```python
def get_currencies(currency_codes: list, url: str = "[https://www.cbr-xml-daily.ru/daily_json.js](https://www.cbr-xml-daily.ru/daily_json.js)") -> dict:
    """
    Получает курсы валют с API Центробанка России.
    :param currency_codes: Список символьных кодов валют (например, ['USD', 'EUR'])
    :return: dict: Словарь, где ключи - символьные коды валют, а значения - их курсы.
                   Возвращает None в случае ошибки запроса.
    """
    try:
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()

        currencies = {}

        if "Valute" in data:
            for code in currency_codes:
                if code in data["Valute"]:
                    currencies[code] = data["Valute"][code]["Value"]
                else:
                    raise KeyError(f"Код валюты '{code}' не найден.")
        else:
            raise KeyError("В ответе API нет ключа 'Valute'")

        return currencies
    except requests.exceptions.ConnectionError:
        raise ConnectionError("API недоступен")

    except requests.exceptions.RequestException as e:
        raise ConnectionError(f"Ошибка сети: {e}")

    except ValueError:
        raise ValueError("Пришел некорректный JSON")
```

#### 3. Демонстрационный пример (квадратное уравнение)

Функция для решения квадратного уравнения. Демонстрирует использование различных уровней логирования (INFO, DEBUG, WARNING, ERROR, CRITICAL) внутри функции при использовании объекта logging.Logger
```python
# Настройка логгера
math_logger = logging.getLogger("quadratic.log")
math_logger.setLevel(logging.DEBUG)
math_handler = logging.FileHandler("quadratic.log", mode='w', encoding='utf-8')
formatter = logging.Formatter('%(levelname)s: %(message)s')
math_handler.setFormatter(formatter)
math_logger.addHandler(math_handler)

@logger(handle=math_logger)
def solve_quadratic(a, b, c):
    math_logger.info(f"Solving equation: {a}x^2 + {b}x + {c} = 0")

    # Ошибка типов
    for name, value in zip(("a", "b", "c"), (a, b, c)):
        if not isinstance(value, (int, float)):
            math_logger.critical(f"Parameter '{name}' must be a number, got: {value}")
            raise TypeError(f"Coefficient '{name}' must be numeric")

    # Ошибка: a == 0
    if a == 0:
        math_logger.error("Coefficient 'a' cannot be zero")
        raise ValueError("a cannot be zero")

    d = b * b - 4 * a * c
    math_logger.debug(f"Discriminant: {d}")

    if d < 0:
        math_logger.warning("Discriminant < 0: no real roots")
        return None

    if d == 0:
        x = -b / (2 * a)
        math_logger.info("One real root")
        return (x,)

    root1 = (-b + math.sqrt(d)) / (2 * a)
    root2 = (-b - math.sqrt(d)) / (2 * a)
    math_logger.info("Two real roots computed")
    return root1, root2
```

#### 4. Скриншоты / фрагменты логов

Лог работы с валютами (currencies.log):  
Пример успешного выполнения функции get_currencies_to_file.  
  
INFO: Запуск функции get_currencies_to_file с аргументами (['USD', 'EUR'],) {}  
INFO: Функция get_currencies_to_file успешно завершена. Результат: {'USD': 79.0246, 'EUR': 90.5625}  


Лог решения квадратных уравнений (quadratic.log):  
Демонстрация различных уровней логирования в зависимости от входных данных.  

INFO: Запуск функции solve_quadratic с аргументами (1, -3, 2) {}  
INFO: Solving equation: 1x^2 + -3x + 2 = 0  
DEBUG: Discriminant: 1  
INFO: Two real roots computed  
INFO: Функция solve_quadratic успешно завершена. Результат: (2.0, 1.0)  
INFO: Запуск функции solve_quadratic с аргументами (1, 1, 10) {}  
INFO: Solving equation: 1x^2 + 1x + 10 = 0  
DEBUG: Discriminant: -39  
WARNING: Discriminant < 0: no real roots  
INFO: Функция solve_quadratic успешно завершена. Результат: None  
INFO: Запуск функции solve_quadratic с аргументами ('строка', 1, 1) {}  
INFO: Solving equation: строкаx^2 + 1x + 1 = 0  
CRITICAL: Parameter 'a' must be a number, got: строка  
ERROR: Ошибка в функции solve_quadratic: TypeError Coefficient 'a' must be numeric  
INFO: Запуск функции solve_quadratic с аргументами (0, 5, 1) {}  
INFO: Solving equation: 0x^2 + 5x + 1 = 0  
ERROR: Coefficient 'a' cannot be zero  
ERROR: Ошибка в функции solve_quadratic: ValueError a cannot be zero  


#### 5. Тесты

Для автоматического тестирования использовался модуль unittest.

Тесты функции

Проверка бизнес-логики get_currencies: корректный возврат типов, обработка ошибок ключа (неверная валюта) и ошибок сети (неверный URL).
```python
class TestGetCurrencies(unittest.TestCase):
    # Тест: Одна корректная валюта
    def test1(self):
        result = main.get_currencies(['USD'])
        self.assertIsInstance(result, dict)
        self.assertIsInstance(result['USD'], (int, float))

    # Тест: Несколько валют
    def test2(self):
        result = main.get_currencies(['USD', 'EUR'])
        self.assertEqual(len(result), 2)

    # Тест: Неправильная валюта
    def test3(self):
        with self.assertRaises(KeyError):
            main.get_currencies(['абвг'])

    # Тест: Неправильный адрес
    def test4(self):
        with self.assertRaises(ConnectionError):
            main.get_currencies(['USD'], url='http/////')
```

Тесты декоратора и работы с StringIO

Проверка работы декоратора: перехват вывода с помощью io.StringIO и анализ записанных логов.
```python
class TestDecorator(unittest.TestCase):
    # Тест: Успешная работа функции
    def test1(self):
        self.stream = io.StringIO()

        @main.logger(handle=self.stream)
        def test_function(x):
            return x ** 2

        test_function(2)
        content = self.stream.getvalue()
        self.assertIn("INFO: Запуск функции test_function с аргументами (2,) {}\n"
                      f"INFO: Функция test_function успешно завершена. Результат: 4", content)

    # Тест: Ошибка в работе функции
    def test2(self):
        self.stream = io.StringIO()

        @main.logger(handle=self.stream)
        def test_function(x):
            return x ** 2

        with self.assertRaises(TypeError):
            test_function('абв')
        content = self.stream.getvalue()
        self.assertRegex(content, "ERROR")
```