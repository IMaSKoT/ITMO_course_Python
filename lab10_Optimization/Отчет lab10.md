### Отчет по лабораторной работе №10
### Методы оптимизации вычисления кода (Потоки, Процессы, Cython, noGIL)
#### Выполнил: Седов Максим, группа P3124
#### 1) Цель работы 
- Сравнить производительность чистого Python, многопоточности (threading) и многопроцессности (multiprocessing)  
- Освоить оптимизацию кода с помощью Cython
- Реализовать отключение GIL (Global Interpreter Lock) для распараллеливания вычислений на потоках  
#### 2) Итерация 1. Реализация на чистом Python
Реализована функция интегрирования методом прямоугольников
```python
def integrate(f, a: float, b: float, *, n_iter: int = 10000000) -> float:
    """
    Функция, вычисляющая интеграл методом прямоугольников
    :param f: Функция, чей интеграл вычисляем
    ...
    >>> round(integrate(math.cos, 0, math.pi / 2, n_iter=100), 5)
    1.00783
    """
    acc = 0
    step = (b - a) / n_iter
    for i in range(n_iter):
        acc += f(a + i * step) * step
    return acc
```
Проведены тесты с использованием pytest (файл Integrate_test.py) для проверки корректности вычислений на разных функциях
#### 3) Итерации 2 и 3. Потоки и Процессы
Были реализованы функции-обертки для запуска вычислений через ThreadPoolExecutor и ProcessPoolExecutor
Наблюдения:  
- Потоки (Threads): В чистом Python не дали прироста производительности (и даже замедлили работу) из-за наличия GIL
- Процессы (Processes): Дали прирост производительности, так как каждый процесс имеет свой интерпретатор и GIL. Однако накладные расходы на создание процессов высоки
#### 4) Итерация 4. Оптимизация с Cython
Создан модуль Integrate_cy.pyx  
Также была реализована версия integrate_sin_pure_c, использующая функцию sin из стандартной библиотеки С (libc.math), а не из модуля math Python, что позволило сократить время выполнения функции.  
Фрагмент Integrate_cy.pyx:
```python
# cython: language_level=3
from libc.math cimport sin

cpdef double integrate_sin_pure_c(double a, double b, long n_iter):
    cdef double acc = 0.0
    cdef double step = (b - a) / n_iter
    cdef int i
    for i in range(n_iter):
        acc += sin(a + i * step) * step
    return acc
```
Результат: Ускорение более чем в 14 раз по сравнению с чистым Python
#### 5) Итерация 5. Отключение GIL (noGIL)
В Cython-модуль добавлена функция с использованием конструкции with nogil. Это сообщает интерпретатору, что блок кода не работает с Python-объектами, и GIL можно отпустить
```python
with nogil:
        for i in range(n_iter):
            acc += sin(a + i * step) * step
```
Это позволило использовать обычные потоки (ThreadPoolExecutor) для реальных параллельных вычислений
#### 6) Результаты замеров производительности
Для замеров использовался модуль timeit, нагрузка 100 млн итераций.
```python
Python (1 поток)	~6.64	Базовая реализация  
Cython (Pure C)	~0.47	Ускорение в ~14 раз за счет типизации  
Cython + Processes	~0.17	Еще быстрее за счет процессов  
Cython + Threads (noGIL)	~0.06	Самый быстрый вариант (на 20 потоках)  
```

При увеличении количества n_jobs потоки с отключенным GIL  работают быстрее процессов, так как используют общую память и не тратят время на создание тяжелых процессов.  
Пример вывода скрипта Iterate5.py:  
```python
noGIL : 20 потоков: 0.0562 сек
GIL   : 20 процессов: 0.1518 сек
```
#### 7) Выводы
В ходе лабораторной работы были изучены методы оптимизации:  
- Чистый Python медленный для математических расчетов из-за динамической типизации
- Cython позволяет получить производительность уровня C/C++, просто добавив типы данных  
- Отключение GIL позволяет эффективно использовать многопоточность, обгоняя даже многопроцессный подход  